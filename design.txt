Tasktory設計メモ

◆今後の作業
・インストーラとスタンドアローン
・各モジュールのテスト
・結合試験の項目作成
・結合試験 (winMain.py)
・例外処理実装

◆将来的に実装したい機能
統計機能
ブラウザによる操作機能
チーム支援機能
タスクトリ合体／吸収機能

◆バグ
○Manager.put() (修正済み)
  ディレクトリが既に存在する場合os.makedirs()がエラーになったため
  ユニットテストの追加／実行はしていない

○Journal.tasktories() (未修正)
  期日がマイナスだと読み込みエラーになる？
  正規表現を修正した

○BOM削除処理が必要
  winMain.py内の読み込みエンコーディングを全て'utf-8-sig'に変更した
  Manager.pyなど、他のコードもチェックする

○親タスクトリの期日が強制的に子タスクトリのもので上書きされた
  Tasktory.__add__()においてdeadlineの更新ロジックを変更した
  (新しい方を使用する、から新しい方を優先する、に変更した)
  Journal.tasktory()においてタスクトリリストのうち末端のもののみにdeadlineを
  設定し、他はNoneに設定するように変更した

○マージがうまくいかない
  deepcopy()内の子タスクトリのコピーが浅いコピーだったのが原因。修正した

○Manager.get_tree()のrenameフラグに誤りがあった
  get_tree()の再帰呼び出しのrenameフラグがデフォルト(False)になっていたので、
  Trueに修正した。テストの追加／実行はしていない

◆課題等
・プロセス終了時の処理問題
  シャットダウンなどによってプロセスが終了する際に処理が中途半端になると良くな
  い。処理を始めたら、確実に終わらせる必要がある。

○タスクトレイに常駐させたい

○エラー通知方法の問題
  ジャーナルのフォーマット誤りなどがあった際に、それを通知する必要がある

  pywin32でMessageBoxを利用するか、バルーンをポップアップさせると良い

○変更されたタスクトリパス解決問題
  タスクトリのパスが変更された際、ジャーナルと同期する必要がある。
  単にタスクトリのパスが変更されただけなら、ファイルシステムを読み直して完全な
  タスクツリーを作成しジャーナルを作成しなおせば良い。しかしタスクトリパス変更
  とジャーナル変更が同時に起こった場合、上記の方法ではジャーナルの変更された情
  報が失われてしまう

  これを解決するためには、変更前後のタスクトリのパスを取得する必要がある。ある
  いは、同時に変更を起こすような微妙な行為はマナー違反として放置するのもアリ

  pywin32を使用し、パス変更後即座にジャーナルに反映するようにした

○モニタリング問題
  ジャーナルやファイルシステムの更新を監視する機構は各OSに用意されているが、OS
  によって実現方法が異なるため、統一できない。重要なのはWindowsだが、この場合
  pywin32などの外部パッケージに頼らざるを得ず、スタンドアロンとするための施策が
  必要である

  妥協案としてポーリングを用いる方法もある。この方法ならOSの機能に依存せず、実
  装も容易である。ただし更新にタイムラグが発生し、マシンに無駄な負荷もかかる。
  とはいえ最初に取る手法としては悪くなく、将来的に性能を追求したくなったら別の
  手段を取れば良い。

  pywin32を使用することにした。linuxやmac版を作る際はinotifyを使用する

○レポートテンプレート問題
  レポートをコンフィグとテンプレートから作成する方法は、柔軟性に欠ける。
  レポートの形式は組織やマネージャによって大きく変わる事が想定されるため、ある
  程度決まった形式のテンプレートしか使用できないのでは、問題がある。

  代案として、コンフィグとテンプレートを提供するのではなく、reportのサブモジュ
  ールを提供する方式なら高い柔軟性を維持できる。
  lib.ui.Report
  lib.ui.report.weekly
  lib.ui.report.monthly
  ただしこの方法では新しいレポートを追加する際に、Tasktoryの知識が必要になり、
  いちいちプログラムを組む必要がある。

  更に代案として、ある程度決まった形式のテンプレートをいくつか用意する方法もあ
  る。この方法を取るには様々なレポートのパターンに精通している必要がある

○ディレクトリ名テンプレート変更問題
  タスクトリが作成するディレクトリ名はコンフィグのテンプレートに従って決定され
  るが、このコンフィグを変更した場合に全ディレクトリ名に即座に反映したい。しか
  し作業中のディレクトリには反映できない、コンフィグの変更を判断する適切な材料
  が無い（ディレクトリ名は書き込み時にしか考慮されないため）、パス変更の影響に
  大して責任が持てない、といった理由であまり良い実装が出来そうに無い。

  （コンフィグ変更の判断について補足）
  テンプレートが"%ID.%NAME"だったとして、その後"%NAME"に変更したとする。
  その後スクリプト側が"1234.HOGE"という名前のディレクトリ（タスクトリ）を見つけ
  たとして、それがIDが1234で名前がHOGEというタスクトリなのか、単に"1234.HOGE"と
  いう名前のタスクトリなのか区別する事が難しい。コンフィグファイルの変更を検出
  するのもあまり気が乗らない

  妥協案になるが、テンプレートの変更が反映されるのは、それ以降のディレクトリ名
  のみにしてしまうと大変楽である。この場合既存のディレクトリ名はユーザーの責任
  で変更して貰う事になる。

○無期タスク問題
  無期限のタスクを許可するかどうか。無期限のタスクは実務上は便利だが、便利すぎ
  るため期限設定を怠けさせる危険がある。いっそ期日をコンストラクタの必須引数に
  するのも手である。しかし許可しない場合は各所で不便を強いられる。例えばジャー
  ナルの出力において無期限タスクをTodoに表示したくないが、その判別は難しい。で
  はConstにするのはどうか。Constも同様に期限の存在しない定常タスクとして追加さ
  れたステータスである（便宜上期限設定は必要だが）。単にカテゴライズのためのタ
  スクトリ（プロジェクト名など）と実際に作業時間が計上される定常タスクは一緒に
  したくない。では専用のステータスをまた追加してはどうか。現時点でジャーナルに
  表示される項目（＝ステータスの数）はTodo, Wait, Done, Constの４つでこれ以上
  の増加は好ましくない。カテゴライズ用の無期限タスクトリも手軽に一覧したい需要
  はあるが、それをジャーナルでやるのは好ましくない。変更しない前提なのでサマリ
  ーなどで表示すべきだ。とはいえ、ステータスを追加したからといってジャーナルに
  追加しなければならないという事はなく、区別のためにステータスを追加するのは有
  効な案である。もちろん、データ構造が複雑になっていくのは避けたいし、ステータ
  スが増える＝状態が増えるなので極力避けたい。

  無期限タスクについてはコンセプトや思想といった根本的な観点から論じるべきであ
  る。全てのタスクには期日を設けるべき、という考え方には一定の説得力がある。そ
  れが直接作業時間を計上しない、プロジェクト名やチーム名であったとしても有限で
  あるのは事実である。こういったものにも期日を適切に設定することで、それが終了
  した後にサマリーを表示する上で恩恵を得られるだろう。また各種処理において、全
  てのタスクトリには期日が設定されている、という前提も得られる。

  無期限タスクは禁止する

  問題は、期日を適切に設定し得ない場合と、各UIにおける分類方法である。前者につ
  いては、ジャーナルから簡単に期日を更新できる事から、仮の期日を設定し更新して
  いけば良い。後者については「十分長い期日」が設定されているタスクを近似的に無
  期タスクとして扱う、専用のステータスを追加する、といった手段が考えら得る。

  1. 期日を利用する
  最も無難で、無期限タスクの性質に近い方法である。問題は期日の更新を前提として
  いる事である。また考えにくいが非常に期日の遠い通常タスクが発生した場合、問題
  が起こる（ただし期日が近くなれば表示されるし、期日が遠くてもしなければならな
  いタスクがあるなら細分化して短い期日を設定するべきであるので、問題は無い）

  2. 専用のステータスを追加する
  過不足無く確実に分類できる方法であるが、ジャーナルに専用の項目を作成する必要
  があるのが非常にイケてない。ジャーナルは使い勝手を重視したいので表示したくな
  い。（できればConstも表示したくない）

  １番を採用することにする。併せて、期日をコンストラクタの必須引数にする

○タスクトリステータス問題
  タスクトリには進行中、待機中、完了などのステータスがあり、そのためのメンバ変
  数も用意されている。そして外部から参照した際に使用する値を共通させるために、
  代入用の定数も定義されていた。しかしTasktory内部ではステータスの値を参照して
  動作を変えることは無く、ステータスを変更することも無い（getterとsetterを定義
  すれば別）。ステータスは飽くまで外部から参照・変更し、外部の動作を制御するた
  めにある。すなわちステータスの意味づけは完全に外部の挙動によって為される。で
  あれば、ステータスの定義（定数定義）自体を外部に明け渡してしまった方が良いの
  ではないか？実際、getterとsetterは使用する機会が殆どなく、外部からの定数への
  参照を抑止できなかったため廃止された。

  かといって、完全に定義を明け渡してしまうと、Tasktory自体は進行、待機、完了と
  いった基本的なタスクの状態を直接はサポートしないという事にもなる。ステータス
  はそっちで決めて、そっちで設定して、勝手に動作を変えてね、という事になる。

  明け渡すことで得られる恩恵は、テストしなくても良いということと、拡張（ステー
  タスの追加）が楽になるという事だ。不便としては、各UIで共通した値が使用できる
  ようにどこかで管理する必要がある事。

  やはり定数定義はTasktory内部で行うことにする

○中間タスクトリに関する問題

  タスクトリは概ね以下のように分類できると考えられる。
  通常タスク : 期限のあるタスク
  定常タスク : 期限の無いタスク
  カテゴリタスク : カテゴライズ用の無期限／無作業タスク

  タスクを作成する際は以下のようにするのが最も良い
  /Project @3560 []
  /Project/Product @365 []
  /Project/Product/Function @30 []
  /Project/Product/Function/Task @5 []
  /Project/Product/Function/Task/Step1 @1 []
  /Project/Product/Function/Task/Step2 @2 []
  /Project/Product/Function/Task/Step3 @3 []
  /Project/Product/Function/Task/Step4 @4 []
  /Project/Product/Function/Task/Step5 @5 []

  しかし以下のようにする事もできる
  /Project/Product/Function/Task/Step1 @1 []
  /Project/Product/Function/Task/Step2 @2 []
  /Project/Product/Function/Task/Step3 @3 []
  /Project/Product/Function/Task/Step4 @4 []
  /Project/Product/Function/Task/Step5 @5 []

  この方法では中間のタスクに期日の設定ができないので、仮の値として末端タスクの
  内、最も値の大きいものを使用する。もちろん、作成済みであればそちらを使う

○ジャーナル由来タスクトリ作成問題

  ジャーナルによるタスクトリ作成ではツリー構造が名前のみで提示されるため、ディ
  レクトリ名が不完全な場合、作成できない。現状ではディレクトリの命名規則を変更
  しても、それが反映されるのは以降に作成される分なので、この状態はよくない。

  加えて、このようなタスクトリを作成してツリーにマージするには親タスクトリへの
  参照が必要になる。Tasktoryに対して、名前などで検索するメソッドを用意したほう
  が良いかもしれない

  タスクトリの唯一の識別子がIDであるのに対して、ジャーナルにはそれが記載されな
  い事が根本的な原因である。そもそもディレクトリの識別子がディレクトリ名である
  のに大してタスクトリ名はそうではないのが諸問題の原因になっている

  そもそもIDを導入したのはディレクトリ名をID.nameといった風に修飾したかったため
  である。しかしその結果ディレクトリ名変更の可能性による諸問題が発生した。IDを
  廃止すればこれらの問題は解決するように思う。

  しかしIDを廃止すると以下のような問題が発生する。
  ・不変の識別子が無くなる
  ・ツリー全体に対する検索性能が弱くなる

  検索性能が弱くなる事については致命的な問題では無いので無視する。不変の識別子
  が無くなる事については、IDは完全廃止はせずに、共有のための識別子として残して
  おき、ローカルでの同定にはタスクトリ名、グローバルの識別子にはIDを使用すると
  いった具合にする

○識別子問題

  識別子を用意する上でいくつかの選択肢がある
  ・不変の識別子IDを用意して、タスクトリの同定はIDで行う
    → 問題がある事が判明している
  ・特別な識別子は用意せず、名前で同定を行う
    → URL生成において問題が起こるのは明らかである
  ・不変の識別子IDを用意するが、同定は基本的に名前で行い、IDは必要な時だけ使う
    → 機能的には十分？
  ・作成された時間、名前等から唯一不変のIDを自動生成する
    → IDを管理する手間が無く優秀？
    → uuidを使用する
